import json
import uuid
import datetime as dt
from pathlib import Path

import yaml

# Repo root: this file lives in scripts/, so parents[1] is the repo root
ROOT = Path(__file__).resolve().parents[1]


def load_config():
    """Load ops/orchestrator-config.yaml."""
    cfg_path = ROOT / "ops" / "orchestrator-config.yaml"
    if not cfg_path.exists():
        raise FileNotFoundError(f"Config file not found: {cfg_path}")
    # utf-8-sig lets us ignore any BOM at the start
    with cfg_path.open("r", encoding="utf-8-sig") as f:
        return yaml.safe_load(f)


def load_queue(queue_path: Path):
    """Read JSONL queue file into a list of task dicts."""
    tasks = []
    if not queue_path.exists():
        raise FileNotFoundError(f"Queue file not found: {queue_path}")
    # utf-8-sig so a BOM at the start of the file does NOT break json.loads
    with queue_path.open("r", encoding="utf-8-sig") as f:
        for line in f:
            # Strip BOM if it somehow appears on a line, then whitespace
            line = line.lstrip("\ufeff").strip()
            if not line:
                continue
            tasks.append(json.loads(line))
    return tasks


def save_queue(queue_path: Path, tasks):
    """Write tasks list back to JSONL."""
    with queue_path.open("w", encoding="utf-8") as f:
        for t in tasks:
            f.write(json.dumps(t))
            f.write("\n")


def summarize_queue(tasks):
    """Count tasks by status."""
    summary = {"todo": 0, "doing": 0, "review": 0, "done": 0, "_other": 0}
    for t in tasks:
        status = str(t.get("status", "")).lower()
        if status in summary:
            summary[status] += 1
        else:
            summary["_other"] += 1
    return summary


def deps_done(task, by_id):
    """Return True if all deps for this task are status == 'done' (or there are none)."""
    deps = task.get("deps") or []
    if not deps:
        return True
    for dep_id in deps:
        dep = by_id.get(dep_id)
        if not dep or dep.get("status") != "done":
            return False
    return True


def pick_next_task(tasks):
    """
    Pick the next task to run:

    - status == 'todo'
    - all deps are 'done'
    - prefer payload.type == 'blueprint_ingest'
    - then sort by phase (asc), weight (desc), id (asc)
    """
    by_id = {t.get("id"): t for t in tasks if "id" in t}
    candidates = []

    for t in tasks:
        if t.get("status") != "todo":
            continue
        if not deps_done(t, by_id):
            continue
        candidates.append(t)

    if not candidates:
        return None

    def sort_key(t):
        payload = t.get("payload") or {}
        ttype = str(payload.get("type", "")).lower()
        type_priority = 0 if ttype == "blueprint_ingest" else 1
        phase = int(t.get("phase", 9999))
        weight = int(t.get("weight", 0))
        tid = str(t.get("id", ""))
        # lower type_priority first, lower phase first, higher weight first
        return (type_priority, phase, -weight, tid)

    candidates.sort(key=sort_key)
    return candidates[0]


def write_task_file(task, cfg):
    """
    Write a simple assignment file under ops/tasks/<OWNER>/<TASK-ID>.md
    so the Cursor agent has a clear brief.
    """
    owner = task.get("owner", "UNASSIGNED")
    orch = cfg.get("orchestrator", {})
    blueprints = cfg.get("blueprints", {})

    tasks_root = ROOT / "ops" / "tasks" / owner
    tasks_root.mkdir(parents=True, exist_ok=True)

    task_id = task.get("id", "UNKNOWN")
    title = task.get("title", "")
    path = tasks_root / f"{task_id}.md"

    lines = []
    lines.append(f"# Task {task_id} – {title}")
    lines.append("")
    lines.append(f"- Owner agent: {owner}")
    lines.append(f"- Initial status: {task.get('status')}")
    lines.append("")
    lines.append("## Queue Payload")
    lines.append("")
    payload_json = json.dumps(task.get("payload", {}), indent=2)
    lines.append("```json")
    lines.append(payload_json)
    lines.append("```")
    lines.append("")
    lines.append("## Context for Cursor Agent")
    lines.append("")
    lines.append("* Use these blueprint sources and derived artifacts when available:")
    lines.append(f"  * Non-technical source: `{blueprints.get('non_tech_source', '')}`")
    lines.append(f"  * Technical source: `{blueprints.get('tech_source', '')}`")
    lines.append(f"  * NT index: `{blueprints.get('nt_index', '')}`")
    lines.append(f"  * TD index: `{blueprints.get('td_index', '')}`")
    lines.append(f"  * Crosswalk: `{blueprints.get('crosswalk', '')}`")
    lines.append(f"  * Acceptance dir: `{blueprints.get('acceptance_dir', '')}`")
    lines.append("")
    lines.append("Follow the orchestrator prompts, run reports, and safety rules defined in the repo.")
    lines.append("")
    lines.append("This file is generated by the RastUp Orchestrator skeleton.")

    text = "\n".join(lines)
    path.write_text(text, encoding="utf-8")
    return path


def main():
    cfg = load_config()
    orch = cfg["orchestrator"]
    project = cfg.get("project", {})

    # Queue path (repo-relative from orchestrator-config.yaml)
    queue_rel = orch["queue_file"]  # e.g. "ops/queue.jsonl"
    queue_path = ROOT / queue_rel

    # Load queue & summarize
    tasks = load_queue(queue_path)
    summary_before = summarize_queue(tasks)

    next_task = pick_next_task(tasks)
    if not next_task:
        print("[orchestrator] No eligible 'todo' tasks with satisfied deps.")
        print(f"[orchestrator] Queue summary: {summary_before}")
        return

    task_id = next_task.get("id", "UNKNOWN")
    owner = next_task.get("owner", "UNASSIGNED")
    title = next_task.get("title", "")

    # Mark as 'doing'
    for t in tasks:
        if t.get("id") == task_id:
            t["status"] = "doing"
            break

    # Save queue back to disk
    save_queue(queue_path, tasks)
    summary_after = summarize_queue(tasks)

    # Write assignment file
    assignment_path = write_task_file(next_task, cfg)

    now = dt.datetime.utcnow().isoformat(timespec="seconds") + "Z"
    print(f"[orchestrator] {now}")
    print(f"[orchestrator] Selected next task: {task_id} – {title}")
    print(f"[orchestrator] Owner agent: {owner}")
    print(f"[orchestrator] Wrote assignment file: {assignment_path}")
    print(
        "[orchestrator] Queue summary before:",
        summary_before,
    )
    print(
        "[orchestrator] Queue summary after: ",
        summary_after,
    )
    print(
        f"[orchestrator] (TODO) This is where we will later call the Cursor CLI "
        f"to run agent {owner} on this assignment."
    )


if __name__ == "__main__":
    main()
